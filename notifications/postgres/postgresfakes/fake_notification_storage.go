// Code generated by counterfeiter. DO NOT EDIT.
package postgresfakes

import (
	"context"
	"sync"

	"github.com/Peripli/service-manager/notifications/postgres"
	"github.com/Peripli/service-manager/pkg/query"
	"github.com/Peripli/service-manager/pkg/types"
	"github.com/Peripli/service-manager/storage"
)

type FakeNotificationStorage struct {
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	CreateStub        func(context.Context, types.Object) (string, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 context.Context
		arg2 types.Object
	}
	createReturns struct {
		result1 string
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CredentialsStub        func() storage.Credentials
	credentialsMutex       sync.RWMutex
	credentialsArgsForCall []struct {
	}
	credentialsReturns struct {
		result1 storage.Credentials
	}
	credentialsReturnsOnCall map[int]struct {
		result1 storage.Credentials
	}
	DeleteStub        func(context.Context, types.ObjectType, ...query.Criterion) (types.ObjectList, error)
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 context.Context
		arg2 types.ObjectType
		arg3 []query.Criterion
	}
	deleteReturns struct {
		result1 types.ObjectList
		result2 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 types.ObjectList
		result2 error
	}
	GetStub        func(context.Context, types.ObjectType, string) (types.Object, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 context.Context
		arg2 types.ObjectType
		arg3 string
	}
	getReturns struct {
		result1 types.Object
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 types.Object
		result2 error
	}
	GetLastRevisionStub        func(context.Context) (int64, error)
	getLastRevisionMutex       sync.RWMutex
	getLastRevisionArgsForCall []struct {
		arg1 context.Context
	}
	getLastRevisionReturns struct {
		result1 int64
		result2 error
	}
	getLastRevisionReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	InTransactionStub        func(context.Context, func(ctx context.Context, storage storage.Repository) error) error
	inTransactionMutex       sync.RWMutex
	inTransactionArgsForCall []struct {
		arg1 context.Context
		arg2 func(ctx context.Context, storage storage.Repository) error
	}
	inTransactionReturns struct {
		result1 error
	}
	inTransactionReturnsOnCall map[int]struct {
		result1 error
	}
	IntroduceStub        func(storage.Entity)
	introduceMutex       sync.RWMutex
	introduceArgsForCall []struct {
		arg1 storage.Entity
	}
	ListStub        func(context.Context, types.ObjectType, ...query.Criterion) (types.ObjectList, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		arg1 context.Context
		arg2 types.ObjectType
		arg3 []query.Criterion
	}
	listReturns struct {
		result1 types.ObjectList
		result2 error
	}
	listReturnsOnCall map[int]struct {
		result1 types.ObjectList
		result2 error
	}
	NewConnectionStub        func(func(isRunning bool, err error)) postgres.NotificationConnection
	newConnectionMutex       sync.RWMutex
	newConnectionArgsForCall []struct {
		arg1 func(isRunning bool, err error)
	}
	newConnectionReturns struct {
		result1 postgres.NotificationConnection
	}
	newConnectionReturnsOnCall map[int]struct {
		result1 postgres.NotificationConnection
	}
	OpenStub        func(*storage.Settings) error
	openMutex       sync.RWMutex
	openArgsForCall []struct {
		arg1 *storage.Settings
	}
	openReturns struct {
		result1 error
	}
	openReturnsOnCall map[int]struct {
		result1 error
	}
	PingStub        func() error
	pingMutex       sync.RWMutex
	pingArgsForCall []struct {
	}
	pingReturns struct {
		result1 error
	}
	pingReturnsOnCall map[int]struct {
		result1 error
	}
	SecurityStub        func() storage.Security
	securityMutex       sync.RWMutex
	securityArgsForCall []struct {
	}
	securityReturns struct {
		result1 storage.Security
	}
	securityReturnsOnCall map[int]struct {
		result1 storage.Security
	}
	UpdateStub        func(context.Context, types.Object, ...*query.LabelChange) (types.Object, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 context.Context
		arg2 types.Object
		arg3 []*query.LabelChange
	}
	updateReturns struct {
		result1 types.Object
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 types.Object
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNotificationStorage) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		return fake.CloseStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.closeReturns
	return fakeReturns.result1
}

func (fake *FakeNotificationStorage) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeNotificationStorage) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeNotificationStorage) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationStorage) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationStorage) Create(arg1 context.Context, arg2 types.Object) (string, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 context.Context
		arg2 types.Object
	}{arg1, arg2})
	fake.recordInvocation("Create", []interface{}{arg1, arg2})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNotificationStorage) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeNotificationStorage) CreateCalls(stub func(context.Context, types.Object) (string, error)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeNotificationStorage) CreateArgsForCall(i int) (context.Context, types.Object) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNotificationStorage) CreateReturns(result1 string, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationStorage) CreateReturnsOnCall(i int, result1 string, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationStorage) Credentials() storage.Credentials {
	fake.credentialsMutex.Lock()
	ret, specificReturn := fake.credentialsReturnsOnCall[len(fake.credentialsArgsForCall)]
	fake.credentialsArgsForCall = append(fake.credentialsArgsForCall, struct {
	}{})
	fake.recordInvocation("Credentials", []interface{}{})
	fake.credentialsMutex.Unlock()
	if fake.CredentialsStub != nil {
		return fake.CredentialsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.credentialsReturns
	return fakeReturns.result1
}

func (fake *FakeNotificationStorage) CredentialsCallCount() int {
	fake.credentialsMutex.RLock()
	defer fake.credentialsMutex.RUnlock()
	return len(fake.credentialsArgsForCall)
}

func (fake *FakeNotificationStorage) CredentialsCalls(stub func() storage.Credentials) {
	fake.credentialsMutex.Lock()
	defer fake.credentialsMutex.Unlock()
	fake.CredentialsStub = stub
}

func (fake *FakeNotificationStorage) CredentialsReturns(result1 storage.Credentials) {
	fake.credentialsMutex.Lock()
	defer fake.credentialsMutex.Unlock()
	fake.CredentialsStub = nil
	fake.credentialsReturns = struct {
		result1 storage.Credentials
	}{result1}
}

func (fake *FakeNotificationStorage) CredentialsReturnsOnCall(i int, result1 storage.Credentials) {
	fake.credentialsMutex.Lock()
	defer fake.credentialsMutex.Unlock()
	fake.CredentialsStub = nil
	if fake.credentialsReturnsOnCall == nil {
		fake.credentialsReturnsOnCall = make(map[int]struct {
			result1 storage.Credentials
		})
	}
	fake.credentialsReturnsOnCall[i] = struct {
		result1 storage.Credentials
	}{result1}
}

func (fake *FakeNotificationStorage) Delete(arg1 context.Context, arg2 types.ObjectType, arg3 ...query.Criterion) (types.ObjectList, error) {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 context.Context
		arg2 types.ObjectType
		arg3 []query.Criterion
	}{arg1, arg2, arg3})
	fake.recordInvocation("Delete", []interface{}{arg1, arg2, arg3})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNotificationStorage) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeNotificationStorage) DeleteCalls(stub func(context.Context, types.ObjectType, ...query.Criterion) (types.ObjectList, error)) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeNotificationStorage) DeleteArgsForCall(i int) (context.Context, types.ObjectType, []query.Criterion) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeNotificationStorage) DeleteReturns(result1 types.ObjectList, result2 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 types.ObjectList
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationStorage) DeleteReturnsOnCall(i int, result1 types.ObjectList, result2 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 types.ObjectList
			result2 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 types.ObjectList
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationStorage) Get(arg1 context.Context, arg2 types.ObjectType, arg3 string) (types.Object, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 context.Context
		arg2 types.ObjectType
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("Get", []interface{}{arg1, arg2, arg3})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNotificationStorage) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeNotificationStorage) GetCalls(stub func(context.Context, types.ObjectType, string) (types.Object, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeNotificationStorage) GetArgsForCall(i int) (context.Context, types.ObjectType, string) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeNotificationStorage) GetReturns(result1 types.Object, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 types.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationStorage) GetReturnsOnCall(i int, result1 types.Object, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 types.Object
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 types.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationStorage) GetLastRevision(arg1 context.Context) (int64, error) {
	fake.getLastRevisionMutex.Lock()
	ret, specificReturn := fake.getLastRevisionReturnsOnCall[len(fake.getLastRevisionArgsForCall)]
	fake.getLastRevisionArgsForCall = append(fake.getLastRevisionArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("GetLastRevision", []interface{}{arg1})
	fake.getLastRevisionMutex.Unlock()
	if fake.GetLastRevisionStub != nil {
		return fake.GetLastRevisionStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getLastRevisionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNotificationStorage) GetLastRevisionCallCount() int {
	fake.getLastRevisionMutex.RLock()
	defer fake.getLastRevisionMutex.RUnlock()
	return len(fake.getLastRevisionArgsForCall)
}

func (fake *FakeNotificationStorage) GetLastRevisionCalls(stub func(context.Context) (int64, error)) {
	fake.getLastRevisionMutex.Lock()
	defer fake.getLastRevisionMutex.Unlock()
	fake.GetLastRevisionStub = stub
}

func (fake *FakeNotificationStorage) GetLastRevisionArgsForCall(i int) context.Context {
	fake.getLastRevisionMutex.RLock()
	defer fake.getLastRevisionMutex.RUnlock()
	argsForCall := fake.getLastRevisionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNotificationStorage) GetLastRevisionReturns(result1 int64, result2 error) {
	fake.getLastRevisionMutex.Lock()
	defer fake.getLastRevisionMutex.Unlock()
	fake.GetLastRevisionStub = nil
	fake.getLastRevisionReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationStorage) GetLastRevisionReturnsOnCall(i int, result1 int64, result2 error) {
	fake.getLastRevisionMutex.Lock()
	defer fake.getLastRevisionMutex.Unlock()
	fake.GetLastRevisionStub = nil
	if fake.getLastRevisionReturnsOnCall == nil {
		fake.getLastRevisionReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.getLastRevisionReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationStorage) InTransaction(arg1 context.Context, arg2 func(ctx context.Context, storage storage.Repository) error) error {
	fake.inTransactionMutex.Lock()
	ret, specificReturn := fake.inTransactionReturnsOnCall[len(fake.inTransactionArgsForCall)]
	fake.inTransactionArgsForCall = append(fake.inTransactionArgsForCall, struct {
		arg1 context.Context
		arg2 func(ctx context.Context, storage storage.Repository) error
	}{arg1, arg2})
	fake.recordInvocation("InTransaction", []interface{}{arg1, arg2})
	fake.inTransactionMutex.Unlock()
	if fake.InTransactionStub != nil {
		return fake.InTransactionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.inTransactionReturns
	return fakeReturns.result1
}

func (fake *FakeNotificationStorage) InTransactionCallCount() int {
	fake.inTransactionMutex.RLock()
	defer fake.inTransactionMutex.RUnlock()
	return len(fake.inTransactionArgsForCall)
}

func (fake *FakeNotificationStorage) InTransactionCalls(stub func(context.Context, func(ctx context.Context, storage storage.Repository) error) error) {
	fake.inTransactionMutex.Lock()
	defer fake.inTransactionMutex.Unlock()
	fake.InTransactionStub = stub
}

func (fake *FakeNotificationStorage) InTransactionArgsForCall(i int) (context.Context, func(ctx context.Context, storage storage.Repository) error) {
	fake.inTransactionMutex.RLock()
	defer fake.inTransactionMutex.RUnlock()
	argsForCall := fake.inTransactionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNotificationStorage) InTransactionReturns(result1 error) {
	fake.inTransactionMutex.Lock()
	defer fake.inTransactionMutex.Unlock()
	fake.InTransactionStub = nil
	fake.inTransactionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationStorage) InTransactionReturnsOnCall(i int, result1 error) {
	fake.inTransactionMutex.Lock()
	defer fake.inTransactionMutex.Unlock()
	fake.InTransactionStub = nil
	if fake.inTransactionReturnsOnCall == nil {
		fake.inTransactionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.inTransactionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationStorage) Introduce(arg1 storage.Entity) {
	fake.introduceMutex.Lock()
	fake.introduceArgsForCall = append(fake.introduceArgsForCall, struct {
		arg1 storage.Entity
	}{arg1})
	fake.recordInvocation("Introduce", []interface{}{arg1})
	fake.introduceMutex.Unlock()
	if fake.IntroduceStub != nil {
		fake.IntroduceStub(arg1)
	}
}

func (fake *FakeNotificationStorage) IntroduceCallCount() int {
	fake.introduceMutex.RLock()
	defer fake.introduceMutex.RUnlock()
	return len(fake.introduceArgsForCall)
}

func (fake *FakeNotificationStorage) IntroduceCalls(stub func(storage.Entity)) {
	fake.introduceMutex.Lock()
	defer fake.introduceMutex.Unlock()
	fake.IntroduceStub = stub
}

func (fake *FakeNotificationStorage) IntroduceArgsForCall(i int) storage.Entity {
	fake.introduceMutex.RLock()
	defer fake.introduceMutex.RUnlock()
	argsForCall := fake.introduceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNotificationStorage) List(arg1 context.Context, arg2 types.ObjectType, arg3 ...query.Criterion) (types.ObjectList, error) {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		arg1 context.Context
		arg2 types.ObjectType
		arg3 []query.Criterion
	}{arg1, arg2, arg3})
	fake.recordInvocation("List", []interface{}{arg1, arg2, arg3})
	fake.listMutex.Unlock()
	if fake.ListStub != nil {
		return fake.ListStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNotificationStorage) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakeNotificationStorage) ListCalls(stub func(context.Context, types.ObjectType, ...query.Criterion) (types.ObjectList, error)) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = stub
}

func (fake *FakeNotificationStorage) ListArgsForCall(i int) (context.Context, types.ObjectType, []query.Criterion) {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	argsForCall := fake.listArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeNotificationStorage) ListReturns(result1 types.ObjectList, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 types.ObjectList
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationStorage) ListReturnsOnCall(i int, result1 types.ObjectList, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 types.ObjectList
			result2 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 types.ObjectList
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationStorage) NewConnection(arg1 func(isRunning bool, err error)) postgres.NotificationConnection {
	fake.newConnectionMutex.Lock()
	ret, specificReturn := fake.newConnectionReturnsOnCall[len(fake.newConnectionArgsForCall)]
	fake.newConnectionArgsForCall = append(fake.newConnectionArgsForCall, struct {
		arg1 func(isRunning bool, err error)
	}{arg1})
	fake.recordInvocation("NewConnection", []interface{}{arg1})
	fake.newConnectionMutex.Unlock()
	if fake.NewConnectionStub != nil {
		return fake.NewConnectionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.newConnectionReturns
	return fakeReturns.result1
}

func (fake *FakeNotificationStorage) NewConnectionCallCount() int {
	fake.newConnectionMutex.RLock()
	defer fake.newConnectionMutex.RUnlock()
	return len(fake.newConnectionArgsForCall)
}

func (fake *FakeNotificationStorage) NewConnectionCalls(stub func(func(isRunning bool, err error)) postgres.NotificationConnection) {
	fake.newConnectionMutex.Lock()
	defer fake.newConnectionMutex.Unlock()
	fake.NewConnectionStub = stub
}

func (fake *FakeNotificationStorage) NewConnectionArgsForCall(i int) func(isRunning bool, err error) {
	fake.newConnectionMutex.RLock()
	defer fake.newConnectionMutex.RUnlock()
	argsForCall := fake.newConnectionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNotificationStorage) NewConnectionReturns(result1 postgres.NotificationConnection) {
	fake.newConnectionMutex.Lock()
	defer fake.newConnectionMutex.Unlock()
	fake.NewConnectionStub = nil
	fake.newConnectionReturns = struct {
		result1 postgres.NotificationConnection
	}{result1}
}

func (fake *FakeNotificationStorage) NewConnectionReturnsOnCall(i int, result1 postgres.NotificationConnection) {
	fake.newConnectionMutex.Lock()
	defer fake.newConnectionMutex.Unlock()
	fake.NewConnectionStub = nil
	if fake.newConnectionReturnsOnCall == nil {
		fake.newConnectionReturnsOnCall = make(map[int]struct {
			result1 postgres.NotificationConnection
		})
	}
	fake.newConnectionReturnsOnCall[i] = struct {
		result1 postgres.NotificationConnection
	}{result1}
}

func (fake *FakeNotificationStorage) Open(arg1 *storage.Settings) error {
	fake.openMutex.Lock()
	ret, specificReturn := fake.openReturnsOnCall[len(fake.openArgsForCall)]
	fake.openArgsForCall = append(fake.openArgsForCall, struct {
		arg1 *storage.Settings
	}{arg1})
	fake.recordInvocation("Open", []interface{}{arg1})
	fake.openMutex.Unlock()
	if fake.OpenStub != nil {
		return fake.OpenStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.openReturns
	return fakeReturns.result1
}

func (fake *FakeNotificationStorage) OpenCallCount() int {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return len(fake.openArgsForCall)
}

func (fake *FakeNotificationStorage) OpenCalls(stub func(*storage.Settings) error) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = stub
}

func (fake *FakeNotificationStorage) OpenArgsForCall(i int) *storage.Settings {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	argsForCall := fake.openArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNotificationStorage) OpenReturns(result1 error) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = nil
	fake.openReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationStorage) OpenReturnsOnCall(i int, result1 error) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = nil
	if fake.openReturnsOnCall == nil {
		fake.openReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.openReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationStorage) Ping() error {
	fake.pingMutex.Lock()
	ret, specificReturn := fake.pingReturnsOnCall[len(fake.pingArgsForCall)]
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct {
	}{})
	fake.recordInvocation("Ping", []interface{}{})
	fake.pingMutex.Unlock()
	if fake.PingStub != nil {
		return fake.PingStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pingReturns
	return fakeReturns.result1
}

func (fake *FakeNotificationStorage) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *FakeNotificationStorage) PingCalls(stub func() error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = stub
}

func (fake *FakeNotificationStorage) PingReturns(result1 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationStorage) PingReturnsOnCall(i int, result1 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	if fake.pingReturnsOnCall == nil {
		fake.pingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationStorage) Security() storage.Security {
	fake.securityMutex.Lock()
	ret, specificReturn := fake.securityReturnsOnCall[len(fake.securityArgsForCall)]
	fake.securityArgsForCall = append(fake.securityArgsForCall, struct {
	}{})
	fake.recordInvocation("Security", []interface{}{})
	fake.securityMutex.Unlock()
	if fake.SecurityStub != nil {
		return fake.SecurityStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.securityReturns
	return fakeReturns.result1
}

func (fake *FakeNotificationStorage) SecurityCallCount() int {
	fake.securityMutex.RLock()
	defer fake.securityMutex.RUnlock()
	return len(fake.securityArgsForCall)
}

func (fake *FakeNotificationStorage) SecurityCalls(stub func() storage.Security) {
	fake.securityMutex.Lock()
	defer fake.securityMutex.Unlock()
	fake.SecurityStub = stub
}

func (fake *FakeNotificationStorage) SecurityReturns(result1 storage.Security) {
	fake.securityMutex.Lock()
	defer fake.securityMutex.Unlock()
	fake.SecurityStub = nil
	fake.securityReturns = struct {
		result1 storage.Security
	}{result1}
}

func (fake *FakeNotificationStorage) SecurityReturnsOnCall(i int, result1 storage.Security) {
	fake.securityMutex.Lock()
	defer fake.securityMutex.Unlock()
	fake.SecurityStub = nil
	if fake.securityReturnsOnCall == nil {
		fake.securityReturnsOnCall = make(map[int]struct {
			result1 storage.Security
		})
	}
	fake.securityReturnsOnCall[i] = struct {
		result1 storage.Security
	}{result1}
}

func (fake *FakeNotificationStorage) Update(arg1 context.Context, arg2 types.Object, arg3 ...*query.LabelChange) (types.Object, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 context.Context
		arg2 types.Object
		arg3 []*query.LabelChange
	}{arg1, arg2, arg3})
	fake.recordInvocation("Update", []interface{}{arg1, arg2, arg3})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNotificationStorage) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeNotificationStorage) UpdateCalls(stub func(context.Context, types.Object, ...*query.LabelChange) (types.Object, error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeNotificationStorage) UpdateArgsForCall(i int) (context.Context, types.Object, []*query.LabelChange) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeNotificationStorage) UpdateReturns(result1 types.Object, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 types.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationStorage) UpdateReturnsOnCall(i int, result1 types.Object, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 types.Object
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 types.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationStorage) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.credentialsMutex.RLock()
	defer fake.credentialsMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.getLastRevisionMutex.RLock()
	defer fake.getLastRevisionMutex.RUnlock()
	fake.inTransactionMutex.RLock()
	defer fake.inTransactionMutex.RUnlock()
	fake.introduceMutex.RLock()
	defer fake.introduceMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.newConnectionMutex.RLock()
	defer fake.newConnectionMutex.RUnlock()
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	fake.securityMutex.RLock()
	defer fake.securityMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNotificationStorage) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ postgres.NotificationStorage = new(FakeNotificationStorage)
