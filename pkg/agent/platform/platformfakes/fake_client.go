// Code generated by counterfeiter. DO NOT EDIT.
package platformfakes

import (
	"sync"

	"github.com/Peripli/service-manager/pkg/agent/platform"
)

type FakeClient struct {
	BrokerStub        func() platform.BrokerClient
	brokerMutex       sync.RWMutex
	brokerArgsForCall []struct {
	}
	brokerReturns struct {
		result1 platform.BrokerClient
	}
	brokerReturnsOnCall map[int]struct {
		result1 platform.BrokerClient
	}
	CatalogFetcherStub        func() platform.CatalogFetcher
	catalogFetcherMutex       sync.RWMutex
	catalogFetcherArgsForCall []struct {
	}
	catalogFetcherReturns struct {
		result1 platform.CatalogFetcher
	}
	catalogFetcherReturnsOnCall map[int]struct {
		result1 platform.CatalogFetcher
	}
	VisibilityStub        func() platform.VisibilityClient
	visibilityMutex       sync.RWMutex
	visibilityArgsForCall []struct {
	}
	visibilityReturns struct {
		result1 platform.VisibilityClient
	}
	visibilityReturnsOnCall map[int]struct {
		result1 platform.VisibilityClient
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) Broker() platform.BrokerClient {
	fake.brokerMutex.Lock()
	ret, specificReturn := fake.brokerReturnsOnCall[len(fake.brokerArgsForCall)]
	fake.brokerArgsForCall = append(fake.brokerArgsForCall, struct {
	}{})
	fake.recordInvocation("Broker", []interface{}{})
	fake.brokerMutex.Unlock()
	if fake.BrokerStub != nil {
		return fake.BrokerStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.brokerReturns
	return fakeReturns.result1
}

func (fake *FakeClient) BrokerCallCount() int {
	fake.brokerMutex.RLock()
	defer fake.brokerMutex.RUnlock()
	return len(fake.brokerArgsForCall)
}

func (fake *FakeClient) BrokerCalls(stub func() platform.BrokerClient) {
	fake.brokerMutex.Lock()
	defer fake.brokerMutex.Unlock()
	fake.BrokerStub = stub
}

func (fake *FakeClient) BrokerReturns(result1 platform.BrokerClient) {
	fake.brokerMutex.Lock()
	defer fake.brokerMutex.Unlock()
	fake.BrokerStub = nil
	fake.brokerReturns = struct {
		result1 platform.BrokerClient
	}{result1}
}

func (fake *FakeClient) BrokerReturnsOnCall(i int, result1 platform.BrokerClient) {
	fake.brokerMutex.Lock()
	defer fake.brokerMutex.Unlock()
	fake.BrokerStub = nil
	if fake.brokerReturnsOnCall == nil {
		fake.brokerReturnsOnCall = make(map[int]struct {
			result1 platform.BrokerClient
		})
	}
	fake.brokerReturnsOnCall[i] = struct {
		result1 platform.BrokerClient
	}{result1}
}

func (fake *FakeClient) CatalogFetcher() platform.CatalogFetcher {
	fake.catalogFetcherMutex.Lock()
	ret, specificReturn := fake.catalogFetcherReturnsOnCall[len(fake.catalogFetcherArgsForCall)]
	fake.catalogFetcherArgsForCall = append(fake.catalogFetcherArgsForCall, struct {
	}{})
	fake.recordInvocation("CatalogFetcher", []interface{}{})
	fake.catalogFetcherMutex.Unlock()
	if fake.CatalogFetcherStub != nil {
		return fake.CatalogFetcherStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.catalogFetcherReturns
	return fakeReturns.result1
}

func (fake *FakeClient) CatalogFetcherCallCount() int {
	fake.catalogFetcherMutex.RLock()
	defer fake.catalogFetcherMutex.RUnlock()
	return len(fake.catalogFetcherArgsForCall)
}

func (fake *FakeClient) CatalogFetcherCalls(stub func() platform.CatalogFetcher) {
	fake.catalogFetcherMutex.Lock()
	defer fake.catalogFetcherMutex.Unlock()
	fake.CatalogFetcherStub = stub
}

func (fake *FakeClient) CatalogFetcherReturns(result1 platform.CatalogFetcher) {
	fake.catalogFetcherMutex.Lock()
	defer fake.catalogFetcherMutex.Unlock()
	fake.CatalogFetcherStub = nil
	fake.catalogFetcherReturns = struct {
		result1 platform.CatalogFetcher
	}{result1}
}

func (fake *FakeClient) CatalogFetcherReturnsOnCall(i int, result1 platform.CatalogFetcher) {
	fake.catalogFetcherMutex.Lock()
	defer fake.catalogFetcherMutex.Unlock()
	fake.CatalogFetcherStub = nil
	if fake.catalogFetcherReturnsOnCall == nil {
		fake.catalogFetcherReturnsOnCall = make(map[int]struct {
			result1 platform.CatalogFetcher
		})
	}
	fake.catalogFetcherReturnsOnCall[i] = struct {
		result1 platform.CatalogFetcher
	}{result1}
}

func (fake *FakeClient) Visibility() platform.VisibilityClient {
	fake.visibilityMutex.Lock()
	ret, specificReturn := fake.visibilityReturnsOnCall[len(fake.visibilityArgsForCall)]
	fake.visibilityArgsForCall = append(fake.visibilityArgsForCall, struct {
	}{})
	fake.recordInvocation("Visibility", []interface{}{})
	fake.visibilityMutex.Unlock()
	if fake.VisibilityStub != nil {
		return fake.VisibilityStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.visibilityReturns
	return fakeReturns.result1
}

func (fake *FakeClient) VisibilityCallCount() int {
	fake.visibilityMutex.RLock()
	defer fake.visibilityMutex.RUnlock()
	return len(fake.visibilityArgsForCall)
}

func (fake *FakeClient) VisibilityCalls(stub func() platform.VisibilityClient) {
	fake.visibilityMutex.Lock()
	defer fake.visibilityMutex.Unlock()
	fake.VisibilityStub = stub
}

func (fake *FakeClient) VisibilityReturns(result1 platform.VisibilityClient) {
	fake.visibilityMutex.Lock()
	defer fake.visibilityMutex.Unlock()
	fake.VisibilityStub = nil
	fake.visibilityReturns = struct {
		result1 platform.VisibilityClient
	}{result1}
}

func (fake *FakeClient) VisibilityReturnsOnCall(i int, result1 platform.VisibilityClient) {
	fake.visibilityMutex.Lock()
	defer fake.visibilityMutex.Unlock()
	fake.VisibilityStub = nil
	if fake.visibilityReturnsOnCall == nil {
		fake.visibilityReturnsOnCall = make(map[int]struct {
			result1 platform.VisibilityClient
		})
	}
	fake.visibilityReturnsOnCall[i] = struct {
		result1 platform.VisibilityClient
	}{result1}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.brokerMutex.RLock()
	defer fake.brokerMutex.RUnlock()
	fake.catalogFetcherMutex.RLock()
	defer fake.catalogFetcherMutex.RUnlock()
	fake.visibilityMutex.RLock()
	defer fake.visibilityMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ platform.Client = new(FakeClient)
